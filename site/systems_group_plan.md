## Sketch of a plan (will changed as we learn more)

We will be choosing on a specific project that should have technical acclaim or otherwise be noteworthy for its role in systems software. Examples that come to mind are SQLite or Redis for their speed and reliability, OpenBSD for its security, the C++ STL for learning about architecting complex libraries and the implementations of modern language primitives, etc.

Once the group has decided on a project to study, we would begin reading about the project. The goal, initially, is to get a high-level understanding of the software. From there, we can formulate specific questions that members investigate or tasks to work on. When we meet, people would present their findings, and there's room to discuss what we found surprising (this is always very interesting) and other thoughts.

Tasks would include things such as "try to make a change here and see what happens" or "can you re-implement a simple version of this." Like reading a programming book, it's crucial to apply what we learn and writing some code helps to gain a much better understanding for what's at play.

For a given project, we meet 2-3 times at minimum with a loose upper bound of not spending more than a few months on the same thing. The people who take part in this should be highly motivated because understanding big systems is hard and we don't want to work to motivate people all the time. But we want to keep the effort low to medium and allow people to take time.

What comes out of it is as yet unclear. The main goal is learning and growing as programmers. But it's conceivable that someone might make a talk, report or open-source project from the work we do together in the group.
